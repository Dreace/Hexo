---
title: Python 手动实现数字验证码识别
tags:
  - Python
  - 网络
  - 验证码识别
typora-root-url: ../../source/
url: 434.html
id: 434
categories:
  - Python
date: 2019-08-03 22:11:37
---

\[title\]背景\[/title\] 本人维护的一个项目[中北信息](https://github.com/Dreace233/NUC-Information)小程序需要模拟登录来获取信息，这就需要在后台识别验证码。需要识别的验证码比较简单且为纯数字，有简单到可以忽略不计的变形，像下面这个样子。

![验证码样例](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE1.png)

图 1 验证码样例

可以看到稍微有一点噪点，应该是压缩解压过程造成的（[JPG](https://zh.wikipedia.org/zh-cn/JPEG) 是有损压缩）。 这是近乎标准印刷体的四位数字，只是有稍微倾斜，最开始想到的办法是 OCR 。 最初使用 [Tesseract](https://github.com/tesseract-ocr/tesseract) 进行本地 OCR 。效果不是很理想，重要问题是 Tesseract 是通用 OCR，他会识别所有的英文字符和标点，这就造成大量的识别不准确。而且 Tesseract 是一个神经网络，在本地运行相当耗费资源。在平时可以应付大部分情况，但在访问高峰时会消耗大量时间在多个识别线程中切换，甚至直接造成服务器宕机。 在没有新的解决方案之前使用了接近一年，只能说勉强能用。 前不久，发现百度云的 OCR 提供每天 5 万次的免费调用，测试发现可以使用且效果不错。使用一段时间后发现一些问题，异步的调用方式造成的延迟不可忽略，尤其是网络延迟。测试发现这个解决方案每个验证码识别有将近 1s 的网络延迟，这使得后台响应时间被延长，影响用户体验。虽然百度云不会将数字识别成其他字符，但经常出现只识别出两位数字的情况造成大量重试，更加影响性能。 两度更换解决方案后，还是没能找到令人满意的方案。决定自己实现验证码的识别，这里不需要训练神经网络，直接通过规则匹配能得到很好的性能与效果，最终单个验证码识别时间为 4-5ms，正确率 100%。 \[title\]识别步骤\[/title\]

1.  灰度化
2.  二值化
3.  切割为单个数字
4.  和字库对比

\[title\]0x00 准备\[/title\] 导入需要用到库

from PIL import Image
import numpy as np
import time
import math
from StringIO import StringIO
import requests
import matplotlib.pyplot as plt
import IdentificationData as ID

这里用到的是 Python 2，因为 Python 3 中 `Image` 库有一些小问题。最后一行导入的是字库，后面会写到。 \[title\]0x01 灰度化\[/title\] 从之前的例子可以看到图像有一些噪点，为了不让其干扰识别需要进行降噪处理。第一步是将图片灰度化，所谓灰度化是将 RGB 色彩空间中三个量合并成一个量 L，这样原本的彩色图像变成灰度图了。每个像素的取值也由 16777216 (2563) 个减少到 256 个，能够减少后继的计算量。将上面的图片灰度化之后变成下面的样子。 ![灰度化后](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE2.png)

图 2 灰度化之后

处理代码

img\_matrix = np.array(Image.open(StringIO(img\_raw)).convert("L"))

其中 `Image.open(StringIO(img_raw)).convert("L")` 是从 `img_raw` 中创建图像并转为灰度图， `img_raw`  可以是从网络加载或从本地文件读入的数据。然后根据灰度图创建一个 [NumPy](https://numpy.org/) 矩阵方便后面的运算。 灰度化之后与原图好像没有区别是因为原图本身是黑白的，如果原图是彩色的话能够很明显地看出区别。 \[title\]0x02 二值化\[/title\] 二值化是将图像的像素与某个阈值比较，若大于这个阈值则设置为灰度最大值（这里是 1，白色），小于某个值则设为灰度最小值（这里是 0，黑色）。这样上一步的灰度图就转化为二值图，便于接下来的图像分割。选择合适的阈值还可以去除图像噪点。 ![二值化后](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE3.png)

图 3 二值化后

二值化后噪点已经完全消失，数字的边界更加锐利。

处理代码

rows, cols = img_matrix.shape  # 获取矩阵（图像）的长宽
for i in range(rows):
    for j in range(cols):
        if img_matrix\[i, j\] <= 128:  # 与阈值比较
            img_matrix\[i, j\] = 0  # 设为灰度最小值
        else:
            img_matrix\[i, j\] = 1  # 设为灰度最大值

\[title\]0x03 切割为单个数字\[/title\] 二值化后可以看到图像中有大量的空白，这对于识别会造成一些影响，并且对比多个验证码发现数字的垂直位置并非固定，也就是上下边距是浮动的。因此要将空白部分删掉只保留有图像的部分 。 先看实现

rows\_max = np.min(img\_matrix, axis=1)  # 每行最小值
rows\_start = np.argmin(rows\_max)  # 找到第一个有图像的行
rows\_end = np.argmin(np.flip(rows\_max))  # 找到最后一个有图像的行
img\_matrix = img\_matrix\[rows\_start:-rows\_end, :\]  # 只取有图像的行

![去除上下空白](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE4.png)

图 4 去除上下空白

`rows_max` 的值为

\[1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\]

其中 1 表示该行最小值为 1 ，在本例中表示这一行都是 1 ，即没有黑色像素。0 则表示这一行有 0 的存在，即存在黑色像素，也就是这一行有图像，需要保留。`np.argmin()` 在 `rows_max` 中查找最小值第一次出现的位置，即为图像开始行。将 `rows_max` 反转之后再次查找最小值下标就得到了结束下标，这个下标的是从右向左计数的。 得到 `rows_start` 和 `rows_end` 后对矩阵进行切片，`rows_end` 要取负值表示表示从右开始计数。 接下来将数字切片成单个

for i in range(4):
    img\_matrix\_split = img_matrix\[:, 19 * i:19 * (i + 1)\]  # 切片
    cols\_max = np.min(img\_matrix_split, axis=0)
    cols\_start = np.argmin(cols\_max)
    cols\_end = np.argmin(np.flip(cols\_max))
    width = cols\_max.shape\[0\] - (cols\_start + cols_end)  # 图像宽度
    width = 9 - width  # 宽度扩宽到 9 像素
    cols_start -= int(math.ceil(width / 2.0))  # 左边界
    cols_end -= int(math.floor(width / 2.0))  # 右边界
    img\_matrix\_split = img\_matrix\_split\[:, cols\_start:-cols\_end\]  # 裁剪为 9 像素宽的图像

先粗略裁剪为每个数字 20 像素，然后再判断左边界和右边界，同之前一样的算法。但是这里不能直接使用得到的边界，每个数字的宽度不一样，直接切片会导致矩阵大小不一样，会影响之后的计算。因此要将将宽度统一为 9 像素，即为最宽的数字宽度。现在可以进行切片了。 ![切片结果-8](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE5-1.png)

图 5-1 切片结果-8

![切片结果-4](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE5-2.png)

图 5-2 切片结果-4

![切片结果-0](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE5-3.png)

图 5-3 切片结果-0

![切片结果=3](https://img.dreace.top/Python%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E5%9B%BE5-4.png)

图 5-4 切片结果-3

\[title\]0x04 和字库对比\[/title\]

res = \[''\] * 10
x = img\_matrix\_split.flatten()  # 展开成一维
for j in range(10):
    y = ID.identification_data\[j\]  # 一次取字库中标准数据
    res\[j\] = np.sum(x ^ y)  # 通过异或计算不同元素的数量
codes\[i\] = str(np.argmin(res))  # 取差异最小的下标

首先将原先的二维矩阵展开为一维，再与字库中的数据对比找到差异最小的那个既是最终结果，这样整个验证码就识别出来了。字库则需要将展开后的矩阵按照顺序整理一下得到。下面是针对这种验证码的字库

import numpy as np
identification_data = \[0\]*10
identification_data\[0\] = np.array(\[1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1\])
identification_data\[1\] = np.array(\[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1\])
identification_data\[2\] = np.array(\[1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\])
identification_data\[3\] = np.array(\[1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1\])
identification_data\[4\] = np.array(\[1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1\])
identification_data\[5\] = np.array(\[1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1\])
identification_data\[6\] = np.array(\[1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1\])
identification_data\[7\] = np.array(\[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1\])
identification_data\[8\] = np.array(\[1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1\])
identification_data\[9\] = np.array(\[1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1\])

至此验证码识别成功。 \[title\]最后\[/title\] 完整的代码可以在这里下载 \[ypbtn\]https://pan.baidu.com/s/1xBuLDOAiuevH2uYNmHhDpg\[/ypbtn\] 要求环境为 Python 2.7，运行前请先安装 `requirements.txt` 中的依赖，压缩包中包含有 100 个同类型验证码可以用作测试。